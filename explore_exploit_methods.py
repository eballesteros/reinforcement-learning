
import numpy as np
import matplotlib.pyplot as plt

from math import sqrt, log

def incremental_average(old_average, new_value, n):
        return (1/n) * (((n - 1) * old_average) + new_value)

class Bandit():
    def __init__(self,true_mean, initial_estimated_value = 0):
        self.true_mean = true_mean
        self.estimated_mean = initial_estimated_value
        self.n_pulls = 0
        self.estimated_mean_evolution = np.array([])
        
    def pull(self):
        reward = np.random.normal(self.true_mean,1)
        self.update(reward)
        return reward
    
    def update(self, reward):
        self.n_pulls += 1
        self.estimated_mean = incremental_average(old_average = self.estimated_mean , new_value = reward, n = self.n_pulls)
        self.estimated_mean_evolution = np.append(self.estimated_mean_evolution,self.estimated_mean)
        
    def get_UCB(self,N): # 0.1 to avoid 0, any small number works
        return self.estimated_mean + sqrt(2 * log(max(N,0.1)) / max(self.n_pulls,0.1))
        
    def __repr__(self):
        return 'Bandit with true mean {}. Estimated mean {} after {} pulls'.\
                format(self.true_mean, self.estimated_mean, self.n_pulls)
        
def epsilon_greedy(m1, m2, m3, eps, N, plot_results = False):
    bandits = [Bandit(m) for m in [m1,m2,m3]]

    data = np.empty(N)

    for i in range(N):
        # epsilon greedy
        p = np.random.random()
        if p < eps:
            j = np.random.choice(3)
        else:
            j = np.argmax([b.estimated_mean for b in bandits])
        x = bandits[j].pull()

        # for the plot
        data[i] = x
    cumulative_average = np.cumsum(data) / (np.arange(N) + 1)
    
    if plot_results:
        # plot moving average ctr
        plt.figure()
        plt.plot(cumulative_average)
        plt.plot(np.ones(N)*m1)
        plt.plot(np.ones(N)*m2)
        plt.plot(np.ones(N)*m3)
        plt.xscale('log')
        plt.show()

        plt.figure()
        for b in bandits:
            plt.plot(b.estimated_mean_evolution, label = str(b.true_mean))
        plt.legend()
        plt.show()

    return cumulative_average

def decaying_epsilon_greedy(m1, m2, m3, eps_o, N, plot_results = False):
    bandits = [Bandit(m) for m in [m1,m2,m3]]

    data = np.empty(N)

    for i in range(N):
        # epsilon greedy
        p = np.random.random()
        if p < eps_o/(i+1):
            j = np.random.choice(3)
        else:
            j = np.argmax([b.estimated_mean for b in bandits])
        x = bandits[j].pull()

        # for the plot
        data[i] = x
    cumulative_average = np.cumsum(data) / (np.arange(N) + 1)
    
    if plot_results:
        # plot moving average ctr
        plt.figure()
        plt.plot(cumulative_average)
        plt.plot(np.ones(N)*m1)
        plt.plot(np.ones(N)*m2)
        plt.plot(np.ones(N)*m3)
        plt.xscale('log')
        plt.show()

        plt.figure()
        for b in bandits:
            plt.plot(b.estimated_mean_evolution, label = str(b.true_mean))
        plt.legend()
        plt.show()

    return cumulative_average

def optimistic_initial_value(m1, m2, m3, initial_value, N, plot_results = False):
    bandits = [Bandit(m, initial_estimated_value = initial_value) for m in [m1,m2,m3]]

    data = np.empty(N)

    for i in range(N):
        j = np.argmax([b.estimated_mean for b in bandits])
        x = bandits[j].pull()

        # for the plot
        data[i] = x
    cumulative_average = np.cumsum(data) / (np.arange(N) + 1)
    
    if plot_results:
        # plot moving average ctr
        plt.plot(cumulative_average)
        plt.plot(np.ones(N)*m1)
        plt.plot(np.ones(N)*m2)
        plt.plot(np.ones(N)*m3)
        plt.xscale('log')
        plt.show()

        plt.figure()
        for b in bandits:
            plt.plot(b.estimated_mean_evolution, label = str(b.true_mean))
        plt.legend()
        plt.show()

    return cumulative_average

def UCB1(m1, m2, m3, N, plot_results = False):
    bandits = [Bandit(m) for m in [m1,m2,m3]]

    data = np.empty(N)

    for i in range(N):
        j = np.argmax([b.get_UCB(N) for b in bandits])
        x = bandits[j].pull()

        # for the plot
        data[i] = x
    cumulative_average = np.cumsum(data) / (np.arange(N) + 1)
    
    if plot_results:
        # plot moving average ctr
        plt.plot(cumulative_average)
        plt.plot(np.ones(N)*m1)
        plt.plot(np.ones(N)*m2)
        plt.plot(np.ones(N)*m3)
        plt.xscale('log')
        plt.show()

        plt.figure()
        for b in bandits:
            plt.plot(b.estimated_mean_evolution, label = str(b.true_mean))
        plt.legend()
        plt.show()

    return cumulative_average


class BayesianBandit:
    def __init__(self, true_mean):
        self.true_mean = true_mean
        # parameters for mu - prior is N(0,1)
        self.predicted_mean = 0
        self.lambda_ = 1
        self.sum_x = 0 # for convenience
        self.tau = 1

    def pull(self):
        return np.random.randn() + self.true_mean

    def sample(self):
        return np.random.randn() / np.sqrt(self.lambda_) + self.predicted_mean

    def update(self, x):
        self.lambda_ += self.tau
        self.sum_x += x
        self.predicted_mean = self.tau*self.sum_x / self.lambda_


def thompson_samplig(m1, m2, m3, N, plot_results = False):
    bandits = [BayesianBandit(m1), BayesianBandit(m2), BayesianBandit(m3)]

    data = np.empty(N)

    for i in range(N):
        # optimistic initial values
        j = np.argmax([b.sample() for b in bandits])
        x = bandits[j].pull()
        bandits[j].update(x)

        # for the plot
        data[i] = x
    cumulative_average = np.cumsum(data) / (np.arange(N) + 1)
    
    if plot_results:
        # plot moving average ctr
        plt.plot(cumulative_average)
        plt.plot(np.ones(N)*m1)
        plt.plot(np.ones(N)*m2)
        plt.plot(np.ones(N)*m3)
        plt.xscale('log')
        plt.show()

    return cumulative_average